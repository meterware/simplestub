<html>
<head>
    <title>SimpleStub: Overview</title>
</head>
<body>
    <h2>Overview</h2>
    <p>Simplestub is a tool which simplifies the creation of test stubs for unit testing. It does so by filling in
    any unimlemented method at compile time. For example, the <code>java.io.ObjectOutput</code> interface has 17 methods
    in JDK 1.6, but in a test that only expects to write byte arrays, the following stub could be sufficient:</p>
    <div class="source">
        <pre>
        <b>import</b> com.meterware.simplestub.SimpleStub

        @SimpleStub
        <b>public abstract class</b> ObjectOutputStub <b>implements</b> ObjectOutput {

            <b>private</b> List&lt;<b>byte</b>[]&gt; bytes = <b>new</b> ArrayList&lt;<b>byte</b>[]&gt;
            <b>boolean</b> closed;

            <b>byte</b>[][] getWrittenBytes() { <b>return</b> b.toArray(<b>new byte</b>[][b.size()]); }
            <b>boolean</b> isClosed() { <b>return</b> closed; }

            <b>public void</b> write(<b>byte</b>[] b) { bytes.add(b); }
            <b>public void</b> close() { closed = true; }
        }</pre>
    </div>

    The test class can be instantiated easily:
    <div class="source">
        <pre>
        <b>import</b> com.meterware.simplestub.Stub

        ObjectOutputStub objectOutput = Stub.create(ObjectOutputStub.<b>class</b>);</pre>
    </div>

    <p>Calls to the defined <code>write</code> method will be captured, and may be retrieved as the test progresses.
        Any call to one of the other methods will do nothing. Alternately, one can set the <code>strict</code> parameter
        of the annotation. If it is set, calls to the undefined methods will throw an exception, generated by SimpleStub.
        This can be useful when working to understand the calls made by legacy code.
    </p>

    <p>
        The create call also takes any number of constructor parameters. SimpleStub will try to find a matching constructor
        defined on the annotation class, and call that.
    </p>


    <h2>Rationale</h2>
    <p>Unit tests often involve stubbing out classes invoked by the System under Test (SUT). The common way to do
    that is simply to implement all of the abstract methods of an interface or abstract class. That can get
    cumbersome when there are a lot of them, especially if the test only needs a handful. IDEs can generate empty
    methods easily; however, that clutters up the test code - and any change to the interface requires updating
    all of the tests which have stubbed it out, even if the don't use those methods.</p>

    <p>One approach to avoid this is to use one of the many Mock libraries, and simply define the behavior for
    the methods to be used; however, that is not strictly their purpose, and the setup code can be difficult to read
    and may need to be repeated with small variations from test to test.</p>

    <p>SimpleStub takes a middle course. Developers define the behavior they want, and let the tool fill in the rest
    at compile time. The stub may then be used as usual.</p>

    <h2>Historical Note</h2>
    <p>The initial implementation of this library, in the <code>org.glassfish.simplestub</code> package, relied
    on compile-time annotation processing to generate stub classes. This turned out to have an unfortunate interaction
    with certain IDEs. The current implementation, in the <code>com.meterware.simplestub</code> package, generates
    stubs at run time, using the <a href="http://javassist.org">Javassist library</a></p>

</body>
</html>